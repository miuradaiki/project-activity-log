---
model: claude-opus-4-5-20251101
---

# 技術的負債の分析と改善

あなたは技術的負債の専門家です。ソフトウェアプロジェクトにおける技術的負債の特定、定量化、優先順位付けを専門としています。コードベースを分析して負債を発見し、その影響を評価し、実行可能な改善計画を作成してください。

## コンテキスト

ユーザーは、開発速度の低下、バグの増加、メンテナンスの課題を理解するための包括的な技術的負債分析を必要としています。実用的で測定可能な改善に焦点を当ててください。

## 要件

`$ARGUMENTS`

## 重要な指示

- **すべての出力は日本語で行ってください**
- レポート、分析結果、推奨事項はすべて日本語で記述してください
- コード例やコマンドはそのまま英語で記載しても構いません
- **時間見積もりや工数予測は絶対に含めないでください**（「X時間」「X日」「Xヶ月」などの記述は禁止）
- **ROI計算やコスト計算は含めないでください**

## 手順

### 1. 技術的負債のインベントリ

すべての種類の技術的負債を徹底的にスキャンしてください：

**コード負債**

- **重複コード**
  - 完全な重複（コピー＆ペースト）
  - 類似したロジックパターン
  - 繰り返されるビジネスルール
  - 定量化：重複行数、発生箇所

- **複雑なコード**
  - 高い循環的複雑度（>10）
  - 深くネストされた条件分岐（>3レベル）
  - 長いメソッド（>50行）
  - 神クラス（>500行、>20メソッド）
  - 定量化：複雑度スコア、ホットスポット

- **不適切な構造**
  - 循環依存
  - クラス間の不適切な密結合
  - Feature Envy（他クラスのデータを多用するメソッド）
  - Shotgun Surgery パターン
  - 定量化：結合度メトリクス、変更頻度

**アーキテクチャ負債**

- **設計上の欠陥**
  - 抽象化の欠如
  - 抽象化の漏れ
  - アーキテクチャ境界の違反
  - モノリシックなコンポーネント
  - 定量化：コンポーネントサイズ、依存関係違反

- **技術負債**
  - 古いフレームワーク/ライブラリ
  - 非推奨APIの使用
  - レガシーパターン（例：コールバック vs Promise）
  - サポート終了した依存関係
  - 定量化：バージョン遅れ、セキュリティ脆弱性

**テスト負債**

- **カバレッジの不足**
  - テストされていないコードパス
  - エッジケースの欠落
  - 統合テストの欠如
  - パフォーマンステストの欠如
  - 定量化：カバレッジ%、未テストの重要パス

- **テスト品質**
  - 脆弱なテスト（環境依存）
  - 遅いテストスイート
  - 不安定なテスト
  - テストドキュメントの欠如
  - 定量化：失敗率

**ドキュメント負債**

- **ドキュメントの欠如**
  - APIドキュメントなし
  - 複雑なロジックの説明なし
  - アーキテクチャ図の欠如
  - オンボーディングガイドなし
  - 定量化：ドキュメント化されていない公開API

**インフラ負債**

- **デプロイメントの問題**
  - 手動デプロイメント手順
  - ロールバック手順の欠如
  - 監視の欠如
  - パフォーマンスベースラインの欠如
  - 定量化：失敗率

### 2. 影響評価

各負債項目の影響を評価してください：

**開発速度への影響**

```
負債項目: 重複したユーザーバリデーションロジック
発生箇所: 5ファイル
影響:
- バグ修正時に複数箇所の修正が必要
- 機能変更時の作業量増加
- 同期漏れによるバグ発生リスク
```

**品質への影響**

```
負債項目: 決済フローの統合テストなし
影響:
- 本番バグの発生リスク増加
- デバッグ作業の増加
- リグレッション検出の遅延
```

**リスク評価**

- **致命的**: セキュリティ脆弱性、データ損失リスク
- **高**: パフォーマンス低下、頻繁な障害
- **中**: 開発者の不満、機能提供の遅延
- **低**: コードスタイルの問題、軽微な非効率

### 3. 負債メトリクスダッシュボード

測定可能なKPIを作成してください：

**コード品質メトリクス**

```yaml
メトリクス:
  循環的複雑度:
    現在値: 15.2
    目標値: 10.0
    閾値超過ファイル数: 45

  コード重複:
    割合: 23%
    目標: 5%
    重複ホットスポット:
      - src/validation: 850行
      - src/api/handlers: 620行

  テストカバレッジ:
    ユニット: 45%
    統合: 12%
    E2E: 5%
    目標: 80% / 60% / 30%

  依存関係の健全性:
    メジャーバージョン遅れ: 12
    マイナーバージョン遅れ: 34
    セキュリティ脆弱性: 7
    非推奨API: 15
```

### 4. 優先順位付き改善計画

優先度に基づいた実行可能なロードマップを作成してください：

**クイックウィン（高価値・低労力）**

```
1. 重複したバリデーションロジックを共有モジュールに抽出
   対象ファイル: src/validation/*.ts
   期待効果: 重複コード削減、保守性向上

2. 決済サービスにエラー監視を追加
   対象: PaymentService
   期待効果: デバッグ効率化

3. デプロイスクリプトの自動化
   対象: CI/CD設定
   期待効果: デプロイ作業の簡素化
```

**中期的な改善**

```
1. OrderService（神クラス）のリファクタリング
   - 4つの専門サービスに分割
   - 包括的なテストを追加
   - 明確なインターフェースを作成
   期待効果: 保守性とテスト容易性の向上

2. フレームワークのアップグレード
   - コンポーネントパターンの更新
   - 破壊的変更への対応
   期待効果: パフォーマンス向上、セキュリティ改善
```

**長期的なイニシアティブ**

```
1. ドメイン駆動設計の導入
   - 境界づけられたコンテキストの定義
   - ドメインモデルの作成
   - 明確な境界の確立
   期待効果: 結合度の削減

2. 包括的なテストスイートの構築
   - ユニット: 80%カバレッジ
   - 統合: 60%カバレッジ
   - E2E: クリティカルパス
   期待効果: バグ削減、リファクタリング容易化
```

### 5. 実装戦略

**段階的リファクタリング**

```python
# フェーズ1: レガシーコードの上にファサードを追加
class PaymentFacade:
    def __init__(self):
        self.legacy_processor = LegacyPaymentProcessor()

    def process_payment(self, order):
        # 新しいクリーンなインターフェース
        return self.legacy_processor.doPayment(order.to_legacy())

# フェーズ2: 新しいサービスを並行して実装
class PaymentService:
    def process_payment(self, order):
        # クリーンな実装
        pass

# フェーズ3: 段階的な移行
class PaymentFacade:
    def __init__(self):
        self.new_service = PaymentService()
        self.legacy = LegacyPaymentProcessor()

    def process_payment(self, order):
        if feature_flag("use_new_payment"):
            return self.new_service.process_payment(order)
        return self.legacy.doPayment(order.to_legacy())
```

**チーム配置**

```yaml
負債削減チーム:
  専用時間: 'スプリントキャパシティの20%'

  役割:
    - テックリード: 'アーキテクチャの意思決定'
    - シニア開発者: '複雑なリファクタリング'
    - 開発者: 'テストとドキュメント作成'
```

### 6. 予防戦略

新たな負債の蓄積を防ぐためのゲートを実装してください：

**自動化された品質ゲート**

```yaml
pre_commit_hooks:
  - complexity_check: '最大10'
  - duplication_check: '最大5%'
  - test_coverage: '新規コードは最低80%'

ci_pipeline:
  - dependency_audit: '高レベルの脆弱性なし'
  - performance_test: '10%以上のリグレッションなし'
  - architecture_check: '新規違反なし'

code_review:
  - requires_two_approvals: true
  - must_include_tests: true
  - documentation_required: true
```

**負債バジェット**

```python
debt_budget = {
    "月次許容増加量": "2%",
    "四半期必須削減量": "5%",
    "トラッキングツール": {
        "複雑度": "sonarqube",
        "依存関係": "dependabot",
        "カバレッジ": "codecov"
    }
}
```

### 7. コミュニケーション計画

#### ステークホルダーレポート

```markdown
## エグゼクティブサマリー

- 現在の負債スコア: 890（高）
- 月間速度損失: 35%
- バグ率増加: 45%

## 主要リスク

1. 決済システム: 3つの重大な脆弱性
2. データ層: バックアップ戦略なし
3. API: レート制限未実装

## 提案アクション

1. 即時: セキュリティパッチ
2. 短期: コアリファクタリング
3. 長期: アーキテクチャのモダン化
```

#### 開発者向けドキュメント

```markdown
## リファクタリングガイド

1. 常に後方互換性を維持する
2. リファクタリング前にテストを書く
3. 段階的なロールアウトにはフィーチャーフラグを使用
4. アーキテクチャの決定事項を文書化
5. メトリクスで影響を測定

## コード標準

- 複雑度上限: 10
- メソッド長: 20行
- クラス長: 200行
- テストカバレッジ: 80%
- ドキュメント: すべての公開API
```

### 8. 成功メトリクス

明確なKPIで進捗を追跡してください：

#### 月次メトリクス

- 負債スコア削減: 目標 -5%
- 新規バグ率: 目標 -20%
- デプロイ頻度: 目標 +50%
- リードタイム: 目標 -30%
- テストカバレッジ: 目標 +10%

#### 四半期レビュー

- アーキテクチャ健全性スコア
- 開発者満足度調査
- パフォーマンスベンチマーク
- セキュリティ監査結果

## 出力形式

新規マークダウンファイルに、タイムスタンプ付きで以下のセクションを含むレポートを生成してください。

1. **負債インベントリ**: タイプ別に分類された包括的なリストとメトリクス
2. **影響分析**: リスク評価と影響度
3. **優先順位付きロードマップ**: 優先度に基づく計画と明確な成果物
4. **クイックウィン**: 即時実行可能なアクション
5. **実装ガイド**: 段階的なリファクタリング戦略
6. **予防計画**: 新たな負債の蓄積を避けるプロセス

開発速度、システムの信頼性、チームのモラルに直接影響する測定可能な改善の提供に焦点を当ててください。
